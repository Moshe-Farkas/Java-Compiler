symbol table:
each scope should have it's own symbol table
scopes are heirarchies
each scope needs a reference to it's parent scope
if a symbol is not in the current scope or it's parent scopes (recursive)
then the symbol is undefined


entries have the format <type,  attribute, modifier>

public   static    int  ok;
    type attribute modifier:
    int  static    public


    vars:
        - stores scope info
        - name
        - type  


task of semantic analysis:
    - Check that identifiers are declared before to be used in computations.
    - Check that reserved keywords are not misused.
    - Check that types are correctly declared, if the language is explicitly typed.
    - Check that computations are type-consistent, wherever possible.


implementing primitive types:
    - defer semantic analysis for later
    - use template pattern for code generation
    - need to visit method bodys and field declaration
    - need to keep track of local var to know their index
    
    code gen visitor:
        - need to visit fields, methods, method declarations.
        - need a constant pool list, methods list and fields list.
        - need to be able to lookup a var name and get it's index
        
    - each method needs a map of var names: index
        
    - code gen is a state machine.
    the states are:
        - in a class def (fields etc...)
        - in a method 
        - in a loop

    - code gen will gen a linear list of enum codes that represent underlying bytecode but
        will defer type specifc codes later

    things that will be replaced later will be things like div, mul, sub, add
    specific const intructions like iconst_2, 3 etc
    the ir will only know int and float types
    
    the ir generator should be the last visitor to visit the source code

    each instruction should be able to store operands

    ir:
        - add, sub, mul, div: 
        - load: varName 
        - store: varName
        

ir eg:
    int ok = 45;
     |
     |
    \./
    INT 45 
    STORE ok
     |
     |
    \./
    bipush 45       // byecode gen will see INT 45 and dispatch a bipush op and 45 const
    istore_1        // will see STORE, lookup varName type and dispatch istore_1 based on var type and index

need to implement a load, store, and integer dispatcher
------------------------
int var1=6;
int var2=4;

int r = var1 + var1;
     |
     |
    \./

iload_1     // load dispatcher dispatched iload_1 because based on the name var1 it's type and index.
load_2
iadd        // add dispatcher dispatched iadd because the two types returned by visit(expr) were int
istore_3    // store dispatcher dispatched because type of r is int

all dispatchers dispatch different things based on wether it's an int or float.

load will dispatch based on if in const range

dispatchers need access to symbol table
symbol table needs an iterface for retriving type and index based on var name

literal dispatcher should have the ability to add constants to the constant pool based on the input.


symbol table for each method:
    - local vars:
        - map: name string: varInfo:
            - varInfo: type, index


ir will type agnostic. 
ir generator and semantic analysis will be the same step
will look like this:
    instruction op...

    load  #local_var_num
    store #local_var_num
    add, sub, div, mul
    push literal


semantic analysis:
    scope:
        + addVar(string)
        + hasVar(string)
        + varType(string) -> varType

TODO: steps:

    - create symbol table:
    - symbol table is a singleton
        - visit all method declarations:
            - add method symbol to symbol table

        - visit all var declarations


semantic analysis:
    for each statement:
        when encountered an identifier in an expression check if:
            - already defined
            - expected type
            